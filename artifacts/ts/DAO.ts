/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  Address,
  Contract,
  ContractState,
  TestContractResult,
  HexString,
  ContractFactory,
  EventSubscribeOptions,
  EventSubscription,
  CallContractParams,
  CallContractResult,
  TestContractParams,
  ContractEvent,
  subscribeContractEvent,
  subscribeContractEvents,
  testMethod,
  callMethod,
  multicallMethods,
  fetchContractState,
  ContractInstance,
  getContractEventsCurrentCount,
  TestContractParamsWithoutMaps,
  TestContractResultWithoutMaps,
  SignExecuteContractMethodParams,
  SignExecuteScriptTxResult,
  signExecuteMethod,
  addStdIdToFields,
  encodeContractFields,
} from "@alephium/web3";
import { default as DAOContractJson } from "../DAO.ral.json";
import { getContractByCodeHash } from "./contracts";

import { RalphMap } from "@alephium/web3";

// Custom types for the contract
export namespace DAOTypes {
  export type Fields = {
    voteTokenId: HexString;
    votingBoxId: HexString;
    quorum: bigint;
    proposalCurrentIndex: bigint;
  };

  export type State = ContractState<Fields>;

  export interface CallMethodTable {
    proposeUpgrade: {
      params: CallContractParams<{ target: HexString }>;
      result: CallContractResult<HexString>;
    };
    executeUpgrade: {
      params: CallContractParams<{ proposalIndex: bigint }>;
      result: CallContractResult<null>;
    };
  }
  export type CallMethodParams<T extends keyof CallMethodTable> =
    CallMethodTable[T]["params"];
  export type CallMethodResult<T extends keyof CallMethodTable> =
    CallMethodTable[T]["result"];
  export type MultiCallParams = Partial<{
    [Name in keyof CallMethodTable]: CallMethodTable[Name]["params"];
  }>;
  export type MultiCallResults<T extends MultiCallParams> = {
    [MaybeName in keyof T]: MaybeName extends keyof CallMethodTable
      ? CallMethodTable[MaybeName]["result"]
      : undefined;
  };
  export type MulticallReturnType<Callss extends MultiCallParams[]> =
    Callss["length"] extends 1
      ? MultiCallResults<Callss[0]>
      : { [index in keyof Callss]: MultiCallResults<Callss[index]> };

  export interface SignExecuteMethodTable {
    proposeUpgrade: {
      params: SignExecuteContractMethodParams<{ target: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    executeUpgrade: {
      params: SignExecuteContractMethodParams<{ proposalIndex: bigint }>;
      result: SignExecuteScriptTxResult;
    };
  }
  export type SignExecuteMethodParams<T extends keyof SignExecuteMethodTable> =
    SignExecuteMethodTable[T]["params"];
  export type SignExecuteMethodResult<T extends keyof SignExecuteMethodTable> =
    SignExecuteMethodTable[T]["result"];
}

class Factory extends ContractFactory<DAOInstance, DAOTypes.Fields> {
  encodeFields(fields: DAOTypes.Fields) {
    return encodeContractFields(
      addStdIdToFields(this.contract, fields),
      this.contract.fieldsSig,
      []
    );
  }

  consts = { ErrorCodes: { ProposalNotAccepted: BigInt("0") } };

  at(address: string): DAOInstance {
    return new DAOInstance(address);
  }

  tests = {
    proposeUpgrade: async (
      params: TestContractParams<
        DAOTypes.Fields,
        { target: HexString },
        { proposals?: Map<bigint, HexString> }
      >
    ): Promise<
      TestContractResult<HexString, { proposals?: Map<bigint, HexString> }>
    > => {
      return testMethod(this, "proposeUpgrade", params, getContractByCodeHash);
    },
    executeUpgrade: async (
      params: TestContractParams<
        DAOTypes.Fields,
        { proposalIndex: bigint },
        { proposals?: Map<bigint, HexString> }
      >
    ): Promise<
      TestContractResult<null, { proposals?: Map<bigint, HexString> }>
    > => {
      return testMethod(this, "executeUpgrade", params, getContractByCodeHash);
    },
  };
}

// Use this object to test and deploy the contract
export const DAO = new Factory(
  Contract.fromJson(
    DAOContractJson,
    "=6-2+7b=2-2+ab=13-1+f=68+7a7e0214696e73657274206174206d617020706174683a2000=210",
    "1c8bd58ac6c5bac71a9deb02583eb095cb439445421b4e2e59e8bacf33d40de3",
    []
  )
);

// Use this class to interact with the blockchain
export class DAOInstance extends ContractInstance {
  constructor(address: Address) {
    super(address);
  }

  maps = {
    proposals: new RalphMap<bigint, HexString>(
      DAO.contract,
      this.contractId,
      "proposals"
    ),
  };

  async fetchState(): Promise<DAOTypes.State> {
    return fetchContractState(DAO, this);
  }

  view = {
    proposeUpgrade: async (
      params: DAOTypes.CallMethodParams<"proposeUpgrade">
    ): Promise<DAOTypes.CallMethodResult<"proposeUpgrade">> => {
      return callMethod(
        DAO,
        this,
        "proposeUpgrade",
        params,
        getContractByCodeHash
      );
    },
    executeUpgrade: async (
      params: DAOTypes.CallMethodParams<"executeUpgrade">
    ): Promise<DAOTypes.CallMethodResult<"executeUpgrade">> => {
      return callMethod(
        DAO,
        this,
        "executeUpgrade",
        params,
        getContractByCodeHash
      );
    },
  };

  transact = {
    proposeUpgrade: async (
      params: DAOTypes.SignExecuteMethodParams<"proposeUpgrade">
    ): Promise<DAOTypes.SignExecuteMethodResult<"proposeUpgrade">> => {
      return signExecuteMethod(DAO, this, "proposeUpgrade", params);
    },
    executeUpgrade: async (
      params: DAOTypes.SignExecuteMethodParams<"executeUpgrade">
    ): Promise<DAOTypes.SignExecuteMethodResult<"executeUpgrade">> => {
      return signExecuteMethod(DAO, this, "executeUpgrade", params);
    },
  };

  async multicall<Callss extends DAOTypes.MultiCallParams[]>(
    ...callss: Callss
  ): Promise<DAOTypes.MulticallReturnType<Callss>> {
    return (await multicallMethods(
      DAO,
      this,
      callss,
      getContractByCodeHash
    )) as DAOTypes.MulticallReturnType<Callss>;
  }
}
